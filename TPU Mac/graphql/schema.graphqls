 type Query {
  currentUser: User
  user(input: UserProfileInput!): PartialUserPublic
  trackedUsers: [PartialUserFriend!]!
  trackedUserIds: [Float!]!
  coreState: CoreState!
  setupStep: Int!
  experiments: [ExperimentType!]!
  weather: Weather!
  collections(input: UserCollectionsInput): PaginatedCollectionResponse
  collection(input: CollectionInput!): Collection
  """
  Return the number of pending invitations for collections for the current user
  """
  collectionInvitesCount: Int!
  domains: [Domain!]!
  gallery(input: GalleryInput!): PaginatedUploadResponse!
  chats(input: ChatsInput): [Chat!]!
  chat(input: ChatInput!): Chat!
  availableChatPermissions: [ChatPermission!]!
  lookupBotPrefix(input: LookupPrefixInput!): Prefix!
  workspaces: [Workspace!]!
  note(input: NoteInput!): Note
  friends(input: FriendsInput): [Friend!]!
  messages(input: InfiniteMessagesInput!): [Message!]!
  messagesPaged(input: PagedMessagesInput!): PaginatedMessageResponse!
  autoCollects(input: UserCollectionsInput!): PaginatedCollectionResponse!
  blockedUsers: [BlockedUser!]!
  chatInvite(input: InviteInput!): ChatInvite
  mailboxes: [ListResponse!]!
  unreadMail: Int!
  getMail(input: GetMailInput!): JSON!
  oauthApps: [OauthApp!]!
  oauthApp(input: MyAppInput!): OauthApp!
  oauthAppConsent(input: MyAppInput!): OauthConsentApp!
  getAuthorizedApps: [OauthApp!]!
  userEmoji: [ChatEmoji!]!
  chatAuditLog(input: AuditLogInput!): PaginatedChatAuditLogResponse!
  autoCollectRules: [AutoCollectRule!]!
  autoCollectRule(input: AutoCollectRuleQueryInput!): AutoCollectRule!
}

type User {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  username: String!
  email: String!
  description: String
  administrator: Boolean!
  darkTheme: Boolean!
  emailVerified: Boolean!
  banned: Boolean!
  inviteId: Float
  discordPrecache: Boolean!
  avatar: String
  subdomainId: Float @deprecated(reason: "Subdomains are no longer available as of TPUv2/NEXT.")
  domainId: Float!
  totpEnable: Boolean!
  """How much the user has uploaded in bytes."""
  quota: Float!
  uploadNameHidden: Boolean! @deprecated(reason: "Hidden upload usernames are no longer available as of TPUv2/NEXT.")
  invisibleURLs: Boolean! @deprecated(reason: "Invisible URLs are no longer available as of TPUv2/NEXT.")
  moderator: Boolean!
  """
  Subscriptions are no longer used as they were in TPUv1, and are now used to store metadata for permanent Gold subscriptions.
  """
  subscriptionId: Float
  fakePath: String @deprecated(reason: "Fake paths are no longer available as of TPUv2/NEXT.")
  themeId: Float! @deprecated(reason: "Replaced with `themeEngine`, used in legacy clients such as legacy.privateuploader.com.")
  itemsPerPage: Float!
  """UserV2 banner."""
  banner: String
  """Ability to login with more then 1 password with different scopes."""
  alternatePasswords: [AlternatePassword!]
  """User status/presence shown to other users."""
  status: UserStatus!
  """
  User status/presence that has `invisible` and is shown to the current user.
  """
  storedStatus: UserStoredStatus!
  weatherUnit: String!
  themeEngine: JSON
  insights: UserInsights!
  profileLayout: JSON
  """Collections that are excluded from the Collections filter in Gallery."""
  excludedCollections: [Float!]
  language: String!
  publicProfile: Boolean!
  """
  How much the user has donated to PrivateUploader. (Likely unused in unofficial instances.)
  """
  xp: Float!
  privacyPolicyAccepted: Boolean
  """The user's name color in Communications."""
  nameColor: String @deprecated(reason: "Replaced by ranks")
  """Whether the user has TPU Pulse Telemetry enabled."""
  pulse: Boolean!
  """Whether the user can be added directly into groups."""
  groupPrivacy: UserGroupPrivacy!
  """Whether the user can be sent a friend request."""
  friendRequests: UserFriendRequestPrivacy!
  """Whether the user is a bot user."""
  bot: Boolean!
  homeWidgets: HomeWidgets
  plan: Plan
  domain: Domain
  subscription: TPUSubscription
  experiments: [Experiment!]
  badges: [Badge!]!
  autoCollectRules: [AutoCollectRule!]!
  """
  The user's scopes assigned to the API key used. In format like `user.view,user.modify` which belong to `Scope`.
  """
  scopes: String
  stats: Stats
  oauthAppId: String
  nickname: [FriendNickname!]
  integrations: [Integration!]!
  notifications: [Notification!]!
  sessions(input: SessionInput): [Session!]!
  """How many AutoCollect approvals the user needs to approve/reject."""
  pendingAutoCollects: Float
  legacy: Boolean!
  friends: [Friend!]!
  mutualCollections: [Collection!]!
  friend: FriendStatus!
}

scalar Date

type AlternatePassword {
  scopes: String!
  totp: Boolean!
  name: String!
}

"""User status/presence shown to other users."""
enum UserStatus {
  ONLINE
  IDLE
  OFFLINE
  BUSY
  UNKNOWN
}

"""
User status/presence that has `invisible` and is shown to the current user.
"""
enum UserStoredStatus {
  ONLINE
  IDLE
  BUSY
  INVISIBLE
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Insights privacy preference."""
enum UserInsights {
  EVERYONE
  FRIENDS
  NOBODY
}

"""Preference of who can add them directly into groups."""
enum UserGroupPrivacy {
  FRIENDS
  NOBODY
}

"""Preference of who can send them friend requests."""
enum UserFriendRequestPrivacy {
  EVERYONE
  NOBODY
}

type HomeWidgets {
  rows: [HomeRow!]!
  default: Boolean
}

type HomeRow {
  widgets: [HomeWidget!]!
  """In UUID format."""
  id: String!
}

type HomeWidget {
  type: HomeWidgetType!
  props: JSON
  """In UUID format."""
  id: String!
}

"""The type of home widget"""
enum HomeWidgetType {
  SITE_STATS
  RECENT_NOTES
  RECENT_COLLECTIONS
  RECENT_UPLOADS
  RECENT_CHATS
  AT_A_GLANCE
  SITE_STATS_GRAPH
  USER_STATS_GRAPH
  USER_STATS
  ANNOUNCEMENTS
}

type Plan {
  id: Int!
  name: String!
  quotaMax: Float!
  price: Float! @deprecated(reason: "Plans are unused in TPUv2+.")
  features: String @deprecated(reason: "Plans are unused in TPUv2+.")
  color: String
  internalName: String!
  purchasable: Boolean! @deprecated(reason: "Plans are unused in TPUv2+.")
  internalFeatures: String @deprecated(reason: "Plans are unused in TPUv2+.")
  icon: String!
}

type Domain {
  id: Int!
  domain: String!
  userId: Int!
  DNSProvisioned: Boolean! @deprecated(reason: "Use `active` instead.")
  active: Boolean!
  zone: String @deprecated(reason: "Cloudflare integration was removed in TPUv2.")
  advanced: Float @deprecated(reason: "Cloudflare integration was removed in TPUv2.")
  subdomains: Boolean! @deprecated(reason: "Subdomains were removed in TPUv2.")
  subdomainsCreate: Boolean! @deprecated(reason: "Subdomains were removed in TPUv2.")
  customUserEligibility: [Int!] @deprecated(reason: "Granular user control was removed in TPUv2.")
  restricted: String! @deprecated(reason: "Granular user control was removed in TPUv2.")
  user: PartialUserBase!
  """Only populated in some admin contexts"""
  users: [PartialUserBase!]
}

type PartialUserBase {
  username: String!
  id: Int!
  createdAt: Date!
  administrator: Boolean!
  moderator: Boolean!
  avatar: String
  bot: Boolean!
  legacy: Boolean!
  badges: [Badge!]!
  notifications: [Notification!]!
  integrations: [Integration!]!
  domain: [Domain!]!
  subscription: [TPUSubscription!]!
  plan: Plan!
  autoCollectRules: AutoCollectRule!
  stats: Stats!
  friends: [Friend!]!
  mutualCollections: [Collection!]!
  friend: FriendStatus!
}

type Badge {
  id: Int!
  name: String!
  description: String
  tooltip: String
  image: String
  icon: String
  color: String
  unlocked: Boolean!
  priority: Float
  plan: Plan!
  users: [PartialUserBase!]!
}

type Notification {
  id: Int!
  message: String!
  userId: Float!
  dismissed: Boolean!
  route: String
  createdAt: Date!
  updatedAt: Date!
  user: PartialUserBase
}

type Integration {
  id: Int!
  userId: Float!
  type: String!
  expiresAt: DateTimeISO
  createdAt: Date!
  updatedAt: Date!
  providerUserId: Float
  providerUsername: String
  providerUserCache: JSON
  error: String
  user: PartialUserBase!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTimeISO

type TPUSubscription {
  planId: Float!
  userId: Float!
  price: Float!
  cancelled: Boolean!
  paymentId: Float!
  expiredAt: DateTimeISO!
  cancelledAt: DateTimeISO!
  metadata: SubscriptionMetadata!
  user: PartialUserBase!
}

type SubscriptionMetadata {
  hours: Float!
}

type AutoCollectRule {
  id: Int!
  name: String!
  enabled: Boolean!
  collectionId: Float!
  requireApproval: Boolean!
  rules: [AutoCollectParentRule!]!
}

type AutoCollectParentRule {
  id: Float!
  rules: [SubRule!]!
}

type SubRule {
  id: Float!
  type: String!
  value: String!
  operator: String!
}

type Stats {
  users: Float!
  announcements: Float!
  usage: Float
  collections: Float!
  collectionItems: Float!
  uploadGraph: DataLabelsGraph
  messageGraph: DataLabelsGraph
  pulseGraph: DataLabelsGraph
  uploads: Float!
  pulse: Float!
  pulses: Float!
  docs: Float!
  hours: JSON
  messages: Float!
}

type DataLabelsGraph {
  data: [Float!]!
  labels: [String!]!
}

type Friend {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  status: FriendStatus!
  userId: Int!
  friendId: Int!
  user: PartialUserFriend!
  otherUser: PartialUserFriend!
}

"""Friend request status."""
enum FriendStatus {
  NONE
  INCOMING
  OUTGOING
  ACCEPTED
}

type PartialUserFriend {
  username: String!
  id: Int!
  createdAt: Date!
  administrator: Boolean!
  moderator: Boolean!
  avatar: String
  bot: Boolean!
  legacy: Boolean!
  badges: [Badge!]!
  notifications: [Notification!]!
  integrations: [Integration!]!
  domain: [Domain!]!
  subscription: [TPUSubscription!]!
  plan: Plan!
  autoCollectRules: AutoCollectRule!
  stats: Stats!
  friends: [Friend!]!
  mutualCollections: [Collection!]!
  friend: FriendStatus!
  status: UserStatus!
  nameColor: String
  nickname: FriendNickname
  blocked: Boolean
  platforms: [Platform!]
}

type Collection {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  name: String!
  """
  Please use field `banner` instead if you want to obtain the banner for a collection.
  """
  image: String
  userId: Float!
  shareLink: String
  avatar: String
  """
  The recommended way to obtain the banner for a collection, it uses field `image`, and if null, falls back to the last added image preview.
  """
  banner: String
  user: PartialUserBase!
  preview: CollectionItem
  users: [CollectionUser!]!
  recipient: CollectionUser
  autoCollectApprovals: [AutoCollectApproval!]!
  shared: Boolean
  itemCount: Int
  attachments: [Upload!]!
  permissionsMetadata: PermissionsMetadata!
  """Used for the frontend for new collections on WebSocket event."""
  new: Boolean
}

type CollectionItem {
  id: Int!
  collectionId: Float!
  attachmentId: Float!
  userId: Float!
  """
  Used to prevent duplicates by forming `uploadId-collectionId`. Can be null for items created before October 2022.
  """
  identifier: String
  createdAt: Date!
  updatedAt: Date!
  pinned: Boolean!
  user: PartialUserBase!
  collection: Collection!
  attachment: Upload!
}

type Upload {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  attachment: String!
  userId: Float!
  name: String
  originalFilename: String
  type: String!
  urlRedirect: String @deprecated(reason: "URL redirects were removed in TPUv2/NEXT.")
  fileSize: Float!
  """
  Non-deletable items are used for profile pictures, banners, etc and are not visible in the Gallery page by default, and cannot be deleted.
  """
  deletable: Boolean!
  """This is used for OCR scanned text from images."""
  textMetadata: String
  user: PartialUserBase
  item: CollectionItem
  collections: [Collection!]!
  items: [CollectionItem!]!
  starred: Star
  autoCollectApproval: AutoCollectApproval
}

type Star {
  id: Int!
  userId: Float!
  attachmentId: Float!
  createdAt: Date!
  updatedAt: Date!
  user: PartialUserBase!
  attachment: Upload!
}

type AutoCollectApproval {
  id: Int!
  autoCollectRuleId: Int!
  uploadId: Float!
  collectionId: Int!
  userId: Int!
  approved: Boolean!
  user: PartialUserBase
  collection: Collection
  autoCollectRule: AutoCollectRule
  attachment: Upload
}

type CollectionUser {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  collectionId: Float!
  read: Boolean!
  write: Boolean!
  configure: Boolean!
  accepted: Boolean!
  recipientId: Float
  senderId: Float
  identifier: String
  collection: Collection
  user: PartialUserBase
  sender: PartialUserBase
}

type PermissionsMetadata {
  write: Boolean!
  read: Boolean!
  configure: Boolean!
}

type FriendNickname {
  id: Int!
  userId: Float!
  createdAt: Date!
  updatedAt: Date!
  friendId: Float!
  nickname: String!
  user: PartialUserBase!
  friend: PartialUserBase!
}

type Platform {
  platform: PlatformType!
  id: String!
  lastSeen: String!
  status: UserStatus!
}

"""Platform type of user device."""
enum PlatformType {
  DESKTOP
  WEB
  MOBILE
}

type Experiment {
  key: String!
  value: String!
  userId: Float!
  user: PartialUserBase!
}

type Session {
  id: Int!
  """Only populated for `API` type sessions on `currentUser`."""
  token: String
  createdAt: Date
  updatedAt: Date
  userId: Float!
  scopes: String!
  type: SessionType!
  expiredAt: DateTimeISO
  name: String
  info: SessionInfo
  oauthAppId: String
}

enum SessionType {
  API
  WEB_SESSION
  OAUTH
}

type SessionInfo {
  accessedFrom: [AccessedFrom!]!
}

type AccessedFrom {
  ip: String!
  userAgent: String
  isp: String
  location: String
  date: String!
  asn: Float
}

input SessionInput {
  type: SessionType!
}

type PartialUserPublic {
  bot: Boolean!
  username: String!
  id: Int!
  createdAt: Date!
  administrator: Boolean!
  moderator: Boolean!
  avatar: String
  badges: [Badge!]!
  banned: Boolean!
  banner: String
  description: String
  friend: FriendStatus
  friends: [Friend!]
  insights: UserInsights!
  plan: Plan!
  platforms: [Platform!]
  profileLayout: ProfileLayout
  publicProfile: Boolean!
  quota: Float!
  stats: Stats
  themeEngine: JSON
  xp: Float
  mutualCollections: [Collection!]!
  notifications: [Notification!]!
  integrations: [Integration!]!
  domain: [Domain!]!
  subscription: [TPUSubscription!]!
  autoCollectRules: AutoCollectRule!
}

type ProfileLayout {
  layout: ProfileLayoutObject!
  config: ProfileLayoutConfig!
  version: Float!
}

type ProfileLayoutObject {
  columns: [ProfileLayoutColumn!]!
}

type ProfileLayoutColumn {
  rows: [ProfileLayoutComponent!]!
}

type ProfileLayoutComponent {
  name: String!
  id: String!
  props: ProfileLayoutProps
}

type ProfileLayoutProps {
  height: Float
  children: [ProfileLayoutComponent!]
  friendsOnly: Boolean
  display: Float
  type: String
  links: [ProfileLayoutPropLink!]
}

type ProfileLayoutPropLink {
  name: String!
  url: String!
  color: String!
}

type ProfileLayoutConfig {
  containerMargin: Float
  showStatsSidebar: Boolean!
}

input UserProfileInput {
  id: Float
  username: String
}

type CoreState {
  connection: Connection!
  name: String!
  """Whether the app is running in production mode."""
  release: String!
  hostname: String!
  hostnameWithProtocol: String!
  announcements: [Announcement!]!
  stats: CoreStats!
  maintenance: Maintenance!
  registrations: Boolean!
  """
  Whether the TPU instance is the officially run instance on privateuploader.com. This can be enabled on any instance but can enable unwanted features.
  """
  officialInstance: Boolean!
  providers: Providers!
  """Workspaces Note ID for the Terms of Service."""
  termsNoteId: String
  """Workspaces Note ID for the Privacy Policy."""
  privacyNoteId: String
  """List of enabled features for TPU instance"""
  features: Features!
  inviteAFriend: Boolean!
  """
  List of domains that are pre-trusted for user-generated hyperlinks such as Communications messages which don't require a confirmation to proceed.
  """
  preTrustedDomains: [String!]!
  hostnames: [String!]!
  _redis: String!
  server: String!
  finishedSetup: Boolean!
  domain: String!
  """Uptime of the TPU Server in seconds."""
  uptime: Float!
  """Uptime of the system in seconds."""
  uptimeSys: Float!
  commitVersion: String!
  weather: Weather!
}

type Connection {
  ip: String!
  whitelist: Boolean! @deprecated(reason: "No longer used in v4.")
}

type Announcement {
  id: Int!
  userId: Float!
  content: String!
  type: String
  createdAt: Date
  updatedAt: Date
  user: PartialUserBase!
}

type CoreStats {
  users: Float!
  announcements: Float!
  usage: Float
  collections: Float!
  collectionItems: Float!
  uploadGraph: DataLabelsGraph
  messageGraph: DataLabelsGraph
  pulseGraph: DataLabelsGraph
  uploads: Float!
  pulse: Float!
  pulses: Float!
  docs: Float!
  hours: JSON
  messages: Float!
  invites: Float!
  inviteMilestone: Float!
  chats: Float!
}

type Maintenance {
  enabled: Boolean!
  message: String
  statusPage: String
}

type Providers {
  anilist: Boolean!
  lastfm: Boolean!
  mal: Boolean!
}

type Features {
  communications: Boolean!
  collections: Boolean!
  autoCollects: Boolean!
  workspaces: Boolean!
  insights: Boolean!
}

type Weather {
  icon: String
  temp: Float
  feels_like: Float
  temp_min: Float
  temp_max: Float
  pressure: Float
  humidity: Float
  wind_speed: Float
  wind_deg: Float
  clouds: Float
  visibility: Float
  error: Boolean
  cached: Boolean
  description: String
  main: String
  location: String
  name: String
}

type ExperimentType {
  id: String!
  value: Int!
  description: String
  createdAt: Date
  refresh: Boolean
}

type PaginatedCollectionResponse {
  items: [Collection!]!
  pager: Pager!
}

type Pager {
  totalItems: Int!
  currentPage: Int!
  pageSize: Int!
  totalPages: Int!
  startPage: Int!
  endPage: Int!
  startIndex: Int!
  endIndex: Int!
  pages: [Float!]!
}

input UserCollectionsInput {
  filter: [CollectionFilter!]! = [ALL]
  search: String
  limit: Float
  page: Float! = 1
  onlyInvited: Boolean! = false
}

"""The type of collection"""
enum CollectionFilter {
  ALL
  WRITE
  READ
  CONFIGURE
  SHARED
  OWNED
}

input CollectionInput {
  id: Int
  shareLink: String
}

type PaginatedUploadResponse {
  items: [Upload!]!
  pager: Pager!
}

input GalleryInput {
  search: String = ""
  page: Int = 1
  limit: Int
  filters: [GalleryFilter!] = [ALL]
  sort: GallerySort = CREATED_AT
  order: GalleryOrder = DESC
  type: GalleryType = PERSONAL
  """Requires Type to be COLLECTION"""
  collectionId: Int
  """Requires Type to be COLLECTION"""
  shareLink: String
  advanced: [SearchModeInput!]
}

"""The filter to apply to the gallery request"""
enum GalleryFilter {
  ALL
  OWNED
  SHARED
  NO_COLLECTION
  IMAGES
  VIDEOS
  GIFS
  AUDIO
  TEXT
  OTHER
  PASTE
  INCLUDE_METADATA
  INCLUDE_UNDELETABLE
  ONLY_UNDELETABLE
}

"""The sort to apply to the gallery request"""
enum GallerySort {
  CREATED_AT
  UPDATED_AT
  ADDED_AT
  NAME
  SIZE
}

"""The order to apply to the gallery request"""
enum GalleryOrder {
  ASC
  DESC
  RANDOM
}

"""
The type of gallery request, for example if it's the personal gallery page, or a Collection
"""
enum GalleryType {
  PERSONAL
  STARRED
  COLLECTION
  AUTO_COLLECT
}

input SearchModeInput {
  mode: GallerySearchMode!
  value: String
}

"""The advanced search mode."""
enum GallerySearchMode {
  AFTER
  DURING
  USER
  SIZE
  NAME
  META
  TYPE
  COLLECTION
  BEFORE
  ORDER
}

type Chat {
  id: Int!
  type: String!
  name: String!
  """
  Null if the chat is owned by a Colubrina legacy user, or the account was deleted.
  """
  userId: Float
  icon: String
  createdAt: DateTimeISO!
  updatedAt: DateTimeISO!
  """This is used if the chat is owned by a Colubrina legacy user."""
  legacyUserId: Float @deprecated(reason: "Use userId instead.")
  """
  Null if the chat is owned by a Colubrina legacy user, or the account was deleted.
  """
  user: PartialUserBase
  """This is used if the chat is owned by a Colubrina legacy user."""
  legacyUser: PartialUserBase @deprecated(reason: "Use user instead.")
  association: ChatAssociation
  users: [ChatAssociation!]!
  description: String
  background: String
  unread: Int
  _redisSortDate: String
  ranks: [ChatRank!]!
  messages: [Message!]!
  """
  Array is empty if you don't have the `OVERVIEW` permission in the chat.
  """
  invites: [ChatInvite!]!
  emoji: [ChatEmoji!]
  usersCount: Int!
  recipient: PartialUserBase
}

type ChatAssociation {
  id: Int!
  chatId: Int!
  userId: Int
  rank: String! @deprecated(reason: "`ChatRank` has replaced legacy rank for granular permission control.")
  lastRead: Int
  createdAt: Date!
  notifications: String!
  """Used for legacy Colubrina accounts."""
  legacyUserId: Int @deprecated(reason: "Use `userId` instead.")
  """
  Only true/false for current user, null for other ChatAssociations. This determines whether the chat is visible in the sidebar (open or closed).
  """
  hidden: Boolean
  inviteUsed: String
  invite: ChatInvite
  """Used for user virtual which falls back to a Colubrina account."""
  tpuUser: PartialUserBase
  """Used for legacy Colubrina accounts."""
  legacyUser: PartialUserBase @deprecated(reason: "Use `user` instead.")
  user: PartialUserBase
  ranks: [ChatRank!]!
  ranksMap: [String!]!
  permissions: [String!]!
}

type ChatInvite {
  id: String!
  userId: Int!
  chatId: Int!
  """
  Automatically assigns rank to user when joining. If unset the backend will set the `managed` Members role.
  """
  rankId: String
  createdAt: Date!
  updatedAt: Date!
  expiredAt: Date
  invalidated: Boolean!
  user: PartialUserBase!
  chat: Chat!
  rank: ChatRank
}

type ChatRank {
  id: String!
  color: String
  name: String!
  userId: Int!
  createdAt: Date
  chatId: Int!
  updatedAt: Date
  managed: Boolean!
  index: Int!
  permissions: [ChatPermission!]!
  permissionsMap: [String!]!
  associations: [ChatAssociation!]!
}

type ChatPermission {
  id: String!
  description: String!
  name: String!
  createdAt: Date
  updatedAt: Date
  group: RankPermissionGroup!
}

"""
The category that the permission is categorized into for Communications ranks.
"""
enum RankPermissionGroup {
  ADMIN
  MANAGE
  GENERAL
  OPTIONS
}

type Message {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  chatId: Int!
  userId: Int
  content: String
  type: MessageType
  embeds: [EmbedDataV2!]!
  edited: Boolean!
  editedAt: Date
  replyId: Int
  legacyUserId: Int
  pinned: Boolean!
  tpuUser: PartialUserBase
  reply: Message
  legacyUser: PartialUserBase
  user: PartialUserBase
  pending: Boolean!
  error: Boolean!
  readReceipts: [ReadReceipt!]!
  chat: Chat!
  emoji: [ChatEmoji!]
}

"""
The type of message. Can be null for legacy (Colubrina) messages where `MESSAGE` should be inferred.
"""
enum MessageType {
  MESSAGE
  LEAVE
  JOIN
  PIN
  ADMINISTRATOR
  RENAME
  SYSTEM
}

type EmbedDataV2 {
  media: [EmbedMedia!]
  text: [EmbedText!]
  metadata: EmbedMetadata!
  version: EmbedVersion!
}

type EmbedMedia {
  url: String
  proxyUrl: String
  attachment: String
  width: Float
  height: Float
  isInternal: Boolean!
  upload: Upload
  mimeType: String
  type: EmbedMediaType!
  """Used for trusted video embed sources, such as YouTube."""
  videoEmbedUrl: String
}

enum EmbedMediaType {
  IMAGE
  VIDEO
  AUDIO
  FILE
}

type EmbedText {
  imageProxyUrl: String
  text: String!
  heading: Boolean
  imageUrl: String
}

type EmbedMetadata {
  url: String
  siteName: String
  siteIcon: String
  footer: String
  type: Float!
  """Used for chat invites, and other embeds."""
  id: String
  """Used for NSFW embeds and content."""
  restricted: Boolean
}

enum EmbedVersion {
  COLUBRINA
  V1
  V2
}

type ReadReceipt {
  chatId: Int!
  associationId: Int!
  messageId: Int!
  user: PartialUserBase!
}

type ChatEmoji {
  id: String!
  userId: Int!
  chatId: Int!
  icon: String
  name: String
  deleted: Boolean!
  createdAt: Date!
  updatedAt: Date!
}

input ChatsInput {
  hidden: Boolean! = false
}

input ChatInput {
  associationId: Int
  chatId: Int
}

type Prefix {
  prefix: String!
  commands: [LookupPrefix!]!
}

type LookupPrefix {
  command: String!
  description: String!
  botId: Float!
}

input LookupPrefixInput {
  chatAssociationId: Int!
  prefix: String!
}

type Workspace {
  id: Int!
  name: String!
  userId: Int!
  createdAt: Date!
  updatedAt: Date!
  icon: String
  user: PartialUserBase!
  folders: [WorkspaceFolder!]!
  users: [WorkspaceUser!]!
}

type WorkspaceFolder {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  name: String!
  workspaceId: Float!
  folderId: Float
  children: [Note!]!
  workspace: Workspace!
}

type Note {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  name: String!
  data: WorkspaceNote
  metadata: WorkspaceNoteMetadata
  workspaceFolderId: Float!
  shareLink: String
  versions: [NoteVersion!]!
  permissions: NotePermissionsMetadata
}

type WorkspaceNote {
  version: String
  blocks: JSON
  time: Float
}

type WorkspaceNoteMetadata {
  version: String
}

type NoteVersion {
  id: String!
  noteId: Int!
  userId: Int!
  data: WorkspaceNote
}

type NotePermissionsMetadata {
  modify: Boolean!
  read: Boolean!
  configure: Boolean!
}

type WorkspaceUser {
  id: Int!
  createdAt: Date!
  updatedAt: Date!
  workspaceId: Float!
  read: Boolean!
  write: Boolean!
  configure: Boolean!
  accepted: Boolean!
  recipientId: Int!
  senderId: Int!
  """The unique identifier between the User and the Workspace."""
  identifier: String
  workspace: Workspace!
  user: PartialUserBase!
  sender: PartialUserBase!
}

input NoteInput {
  id: Float
  shareLink: String
}

input FriendsInput {
  status: FriendStatus
}

input InfiniteMessagesInput {
  associationId: Int!
  position: ScrollPosition
  search: MessagesSearch
  limit: Int! = 50
  offset: Int
}

"""The position to retrieve messages from based on the `offset`."""
enum ScrollPosition {
  TOP
  BOTTOM
}

input MessagesSearch {
  query: String
  userId: Int
  before: Date
  after: Date
  pins: Boolean
}

type PaginatedMessageResponse {
  items: [Message!]!
  pager: Pager!
}

input PagedMessagesInput {
  associationId: Int!
  position: ScrollPosition
  search: MessagesSearch
  limit: Int! = 50
  page: Int! = 1
}

type BlockedUser {
  id: String!
  userId: Int!
  createdAt: Date!
  updatedAt: Date!
  blockedUserId: Int!
  """
  To the blocked user it appears as though they're unblocked, however the blocker will not receive any messages from them, and their messages will be hidden inside of group chats.
  """
  silent: Boolean!
  user: PartialUserBase
  blockedUser: PartialUserBase
}

input InviteInput {
  inviteId: String!
}

type ListResponse {
  path: String!
  name: String!
  delimiter: String!
  flags: [String!]!
  specialUse: String
  listed: Boolean!
  subscribed: Boolean
}

input GetMailInput {
  userId: Float!
  mailbox: String!
  page: Float
}

type OauthApp {
  id: String!
  name: String!
  icon: String
  shortCode: String
  verified: Boolean!
  redirectUri: String
  secret: String
  description: String
  scopes: String!
  userId: Float!
  botId: Float
  private: Boolean!
  user: PartialUserBase!
  bot: PartialUserBase
  oauthUsers: [OauthUser!]!
  oauthUser: OauthUser!
  token: String
}

type OauthUser {
  id: String!
  userId: Float!
  oauthAppId: String!
  active: Boolean!
  createdAt: Date!
  updatedAt: Date!
  manage: Boolean!
  user: PartialUserBase!
}

input MyAppInput {
  id: String!
}

type OauthConsentApp {
  id: String!
  name: String!
  icon: String
  shortCode: String
  verified: Boolean!
  redirectUri: String
  description: String
  scopes: String!
  userId: Float!
  botId: Float
  private: Boolean!
  user: PartialUserBase!
  bot: PartialUserBase
  token: String
}

type PaginatedChatAuditLogResponse {
  items: [ChatAuditLog!]!
  pager: Pager!
}

type ChatAuditLog {
  id: String!
  userId: Int!
  chatId: Int!
  category: AuditLogCategory!
  actionType: AuditLogActionType!
  message: String!
  createdAt: Date!
  updatedAt: Date!
}

"""Used for chat audit log."""
enum AuditLogCategory {
  USER
  RANK
  MESSAGE
  INVITE
  PIN_MESSAGE
  BOT
  SETTINGS
  EMOJI
}

"""
Used for chat audit log to determine what type of action was performed.
"""
enum AuditLogActionType {
  MODIFY
  ADD
  REMOVE
}

input AuditLogInput {
  associationId: Int!
  page: Float! = 1
  limit: Float! = 24
}

input AutoCollectRuleQueryInput {
  id: Int!
}

type Mutation {
  updateUser(input: UpdateUserInput!): Boolean!
  updateStatus(input: UpdateUserStatusInput!): UserStoredStatus!
  changeUserPassword(input: ChangePasswordInput!): Boolean!
  changeUsername(input: ChangeUsernameInput!): Boolean!
  changeUserEmail(input: ChangeEmailInput!): Boolean!
  verifyEmail(token: String!): Boolean!
  resendVerificationEmail: Boolean!
  login(input: LoginInput!): LoginResponse!
  logout: Boolean!
  register(input: RegisterInput!): LoginResponse!
  setExperiment(input: SetExperimentInput!): Experiment!
  createCollection(input: CreateCollectionInput!): Collection!
  updateCollection(input: UpdateCollectionInput!): Collection!
  updateCollectionUserPermissions(input: UpdateCollectionUserPermissionsInput!): CollectionUser!
  addCollectionUser(input: UpdateCollectionUserPermissionsInput!): CollectionUser!
  removeCollectionUser(input: RemoveCollectionUserInput!): GenericSuccessObject!
  transferCollectionOwnership(input: TransferCollectionOwnershipInput!): GenericSuccessObject!
  actOnCollectionInvite(input: AcceptCollectionInviteInput!): GenericSuccessObject!
  leaveCollection(input: LeaveCollectionInput!): GenericSuccessObject!
  applyDomain(domainId: Int!): Domain!
  deleteUploads(input: DeleteUploadInput!): GenericSuccessObject!
  updateUpload(input: UpdateUploadInput!): Upload!
  starUpload(input: StarUploadInput!): StarUploadResponse!
  createChat(input: CreateChatInput!): Chat!
  updateChat(input: UpdateChatInput!): Chat!
  deleteGroup(input: DangerZoneChatInput!): GenericSuccessObject!
  transferGroupOwnership(input: TransferOwnershipInput!): Chat!
  typing(input: Float!): Boolean!
  cancelTyping(input: Float!): Boolean!
  addChatUsers(input: AddChatUser!): GenericSuccessObject!
  toggleUserRank(input: AddRank!): GenericSuccessObject!
  leaveChat(input: LeaveChatInput!): GenericSuccessObject!
  joinChatFromInvite(input: JoinChatFromInviteInput!): ChatAssociation!
  addBotToChat(input: AddBotToChatInput!): ChatAssociation!
  readChat(input: ReadChatInput!): GenericSuccessObject!
  """Create a new Workspace Folder."""
  createWorkspaceFolder(input: CreateWorkspaceFolderInput!): WorkspaceFolder!
  """Create workspace"""
  createWorkspace(
    """Name of workspace"""
    input: String!
  ): Workspace!
  """Delete a Note."""
  deleteWorkspaceItem(input: DeleteWorkspaceItemInput!): Boolean!
  saveNote(input: SaveNoteInput!): Note!
  createNote(input: CreateNoteInput!): Note!
  """Toggle the ShareLink for a Note."""
  toggleNoteShare(
    """ID of Note"""
    input: Int!
  ): Note!
  friend(input: AddFriendInput!): Boolean!
  sendMessage(input: SendMessageInput!): Message!
  editMessage(input: EditMessageInput!): Message
  deleteMessage(input: DeleteMessageInput!): Boolean!
  updateChatRank(input: UpdateRank!): ChatRank!
  addChatRank(input: CreateRank!): ChatRank!
  updateChatRankOrder(input: UpdateRankOrder!): [ChatRank!]!
  deleteChatRank(input: DeleteRank!): GenericSuccessObject!
  actOnAutoCollects(input: ActOnAutoCollectsInput!): GenericSuccessObject!
  addToCollection(input: AddToCollectionInput!): [CollectionItem!]!
  removeFromCollection(input: AddToCollectionInput!): Int!
  adminMigrateLegacyRanksForChat: GenericSuccessObject!
  adminSendEmailForUnverifiedUsers: GenericSuccessObject!
  adminClearCache(input: ClearCacheInput!): GenericSuccessObject!
  adminDebugBatch: GenericSuccessObject!
  adminMigrateLegacyToNormalUsers: GenericSuccessObject!
  adminGenerateInsights(customGte: String, type: String!, userId: Float!): GenericSuccessObject!
  blockUser(input: BlockUserInput!): GenericSuccessObject!
  createChatInvite(input: CreateInviteInput!): ChatInvite!
  invalidateChatInvite(input: InvalidateInviteInput!): GenericSuccessObject!
  oauthAppAuthorize(input: AuthorizeAppInput!): AuthorizeAppResponse!
  oauthAppDeauthorize(input: MyAppInput!): GenericSuccessObject!
  createOauthApp(input: CreateAppInput!): OauthApp!
  deleteOauthApp(input: MyAppInput!): GenericSuccessObject!
  resetOauthSecret(input: MyAppInput!): GenericSuccessObject!
  updateOauthApp(input: UpdateAppInput!): GenericSuccessObject!
  createBotOauthApp(input: CreateBotInput!): PartialUserBase!
  updateOauthUser(input: UpdateAppUserInput!): OauthUser!
  addOauthUser(input: AddAppUserInput!): OauthUser!
  registerBotPrefix(input: RegisterPrefix!): GenericSuccessObject!
  registerBotCommands(input: RegisterCommands!): GenericSuccessObject!
  updateEmoji(input: UpdateEmojiInput!): ChatEmoji!
  deleteEmoji(input: DeleteEmojiInput!): GenericSuccessObject!
  createPulse(input: PulseInput!): String!
  createSinglePulse(input: SinglePulseInput!): String!
  updatePulse(input: PulseUpdateInput!): String!
  embedResolutionPrecache(input: EmbedPrecacheInput!): EmbedDataV2
}

input UpdateUserInput {
  username: String
  email: String
  discordPrecache: Boolean
  darkTheme: Boolean
  description: String
  itemsPerPage: Float
  storedStatus: String
  weatherUnit: String
  themeEngine: JSON
  insights: String
  profileLayout: JSON
  language: String
  excludedCollections: [Float!]
  publicProfile: Boolean
  privacyPolicyAccepted: Boolean
  nameColor: String
  groupPrivacy: UserGroupPrivacy
  pulse: Boolean
  friendRequests: UserFriendRequestPrivacy
}

input UpdateUserStatusInput {
  storedStatus: UserStoredStatus!
}

input ChangePasswordInput {
  totp: String
  currentPassword: String!
  newPassword: String!
}

input ChangeUsernameInput {
  """You may use either 2FA token or password to delete the chat."""
  password: String
  """
  TOTP/2FA code if enabled. You may use either 2FA token or password to delete the chat.
  """
  totp: String
  username: String!
}

input ChangeEmailInput {
  """You may use either 2FA token or password to delete the chat."""
  password: String
  """
  TOTP/2FA code if enabled. You may use either 2FA token or password to delete the chat.
  """
  totp: String
  email: String!
}

type LoginResponse {
  token: String!
  user: LoginUser!
}

type LoginUser {
  id: Float!
  username: String!
  email: String!
}

input LoginInput {
  """Username or email"""
  username: String!
  password: String!
  """TOTP/2FA code if enabled."""
  totp: String
}

input RegisterInput {
  username: String!
  password: String!
  email: String!
  inviteKey: String
}

input SetExperimentInput {
  key: String!
  value: Int!
  """Admin only."""
  userId: Int
}

input CreateCollectionInput {
  name: String!
}

input UpdateCollectionInput {
  collectionId: Int!
  name: String
  shareLink: Boolean
}

input UpdateCollectionUserPermissionsInput {
  userId: Int!
  collectionId: Int!
  read: Boolean!
  write: Boolean!
  configure: Boolean!
}

type GenericSuccessObject {
  success: Boolean!
}

input RemoveCollectionUserInput {
  userId: Int!
  collectionId: Int!
}

input TransferCollectionOwnershipInput {
  """You may use either 2FA token or password to delete the chat."""
  password: String
  """
  TOTP/2FA code if enabled. You may use either 2FA token or password to delete the chat.
  """
  totp: String
  userId: Int!
  collectionId: Int!
}

input AcceptCollectionInviteInput {
  collectionId: Int!
  accept: Boolean!
}

input LeaveCollectionInput {
  collectionId: Int!
}

input DeleteUploadInput {
  items: [Float!]!
}

input UpdateUploadInput {
  uploadId: Int!
  name: String!
}

type StarUploadResponse {
  status: Boolean!
  star: Star
}

input StarUploadInput {
  """The upload's attachment ID, not numerical ID, such as 1d7fe21g3jd1.png"""
  attachment: String!
}

input CreateChatInput {
  users: [Float!]!
  name: String
}

input UpdateChatInput {
  name: String
  associationId: Int!
  """
  Can only be null or undefined to unset or do not modify the group icon respectively. Use the REST API to set one.
  """
  icon: String
  """
  Can only be null or undefined to unset or do not modify the group background respectively. Use the REST API to set one.
  """
  background: String
  description: String
}

"""Used for deleting chats and transferring ownership."""
input DangerZoneChatInput {
  """You may use either 2FA token or password to delete the chat."""
  password: String
  """
  TOTP/2FA code if enabled. You may use either 2FA token or password to delete the chat.
  """
  totp: String
  associationId: Int!
}

input TransferOwnershipInput {
  """You may use either 2FA token or password to delete the chat."""
  password: String
  """
  TOTP/2FA code if enabled. You may use either 2FA token or password to delete the chat.
  """
  totp: String
  associationId: Int!
  """User to transfer to."""
  userId: Int!
}

input AddChatUser {
  chatAssociationId: Int!
  users: [Float!]!
  action: ToggleUser!
}

"""Whether the user should be added, or removed from the group."""
enum ToggleUser {
  ADD
  REMOVE
}

input AddRank {
  chatAssociationId: Int!
  updatingChatAssociationId: Int!
  rankId: String!
}

input LeaveChatInput {
  associationId: Int!
}

input JoinChatFromInviteInput {
  inviteId: String!
}

input AddBotToChatInput {
  associationId: Int!
  botAppId: String!
  permissions: [String!]!
}

input ReadChatInput {
  associationId: Int!
}

input CreateWorkspaceFolderInput {
  name: String!
  workspaceId: Float!
}

input DeleteWorkspaceItemInput {
  id: Float!
  type: WorkspaceItemType!
}

"""The type of workspace item"""
enum WorkspaceItemType {
  NOTE
  FOLDER
  WORKSPACE
}

input SaveNoteInput {
  id: Float!
  data: WorkspaceNoteInput!
  manualSave: Boolean
  name: String
}

input WorkspaceNoteInput {
  version: String
  blocks: JSON
  time: Float
}

input CreateNoteInput {
  workspaceFolderId: Float!
  name: String!
}

input AddFriendInput {
  """Can use `userId` or `username`"""
  userId: Int
  """Can use `userId` or `username`"""
  username: String
  """If null, it works as a toggle. This is for explicit actions."""
  action: FriendAction
}

enum FriendAction {
  SEND
  REMOVE
  ACCEPT
}

input SendMessageInput {
  content: String!
  associationId: Int!
  attachments: [String!]! = []
  replyId: Int
  embeds: [EmbedInput!]
}

input EmbedInput {
  url: String
  title: String
  description: String
  siteName: String
  type: String
  image: String
  color: String
  graph: InteractiveGraphInput
}

input InteractiveGraphInput {
  type: String!
}

input EditMessageInput {
  content: String
  attachments: [String!]! = []
  messageId: Int!
  embeds: [EmbedInput!]
  associationId: Int!
  pinned: Boolean
}

input DeleteMessageInput {
  messageId: Int!
  associationId: Int!
}

input UpdateRank {
  associationId: Int!
  rankId: String!
  permissionsMap: [String!]!
  name: String
  color: String
}

input CreateRank {
  associationId: Int!
  name: String
  color: String
}

input UpdateRankOrder {
  associationId: Int!
  """
  Order if the rank, this is actually reversed from expected index value, so rankIds[0] is the highest priority rank.
  """
  rankIds: [String!]!
}

input DeleteRank {
  associationId: Int!
  rankId: String!
}

input ActOnAutoCollectsInput {
  items: [Int!]!
  action: AutoCollectAction!
}

enum AutoCollectAction {
  APPROVE
  REJECT
}

input AddToCollectionInput {
  collectionId: Float!
  items: [Float!]!
}

input ClearCacheInput {
  userId: Int
  type: AdminCacheType!
  await: Boolean = false
}

"""The type of cache to clear"""
enum AdminCacheType {
  everything
  state
  collections
  sharelinks
  autocollects
  invites
  chats
  insights
  userstats
  lastfm
  mal
  trackedUsers
  users
}

input BlockUserInput {
  userId: Int!
  silent: Boolean!
}

input CreateInviteInput {
  """In hours."""
  expiry: Int
  """Auto assign rank on join."""
  rankId: String
  associationId: Int!
}

input InvalidateInviteInput {
  associationId: Int!
  inviteId: String!
}

type AuthorizeAppResponse {
  token: String
}

input AuthorizeAppInput {
  id: String!
  scopes: String!
  """Used for bots."""
  permissions: [String!]
}

input CreateAppInput {
  name: String!
  description: String
  redirectUri: String
  private: Boolean!
  verified: Boolean!
}

input UpdateAppInput {
  name: String!
  description: String
  redirectUri: String
  private: Boolean!
  verified: Boolean!
  id: String!
  scopes: [String!]
}

input CreateBotInput {
  id: String!
  username: String!
}

input UpdateAppUserInput {
  id: String!
  oauthAppId: String!
  manage: Boolean!
}

input AddAppUserInput {
  username: String!
  oauthAppId: String!
  manage: Boolean
}

input RegisterPrefix {
  prefix: String!
}

input RegisterCommands {
  commands: [RegisterCommand!]!
}

input RegisterCommand {
  command: String!
  description: String!
}

input UpdateEmojiInput {
  id: String!
  name: String!
  associationId: Int!
}

input DeleteEmojiInput {
  id: String!
  associationId: Int!
}

input PulseInput {
  type: String!
  id: String
  action: String!
  route: String!
  device: String!
  sysInfo: PulseUserAgent!
  name: String
  other: JSON
}

input PulseUserAgent {
  ua: String!
}

input SinglePulseInput {
  type: String!
  id: String
  action: String!
  route: String!
  device: String!
  sysInfo: PulseUserAgent!
  name: String
  other: JSON
  timeSpent: Float!
}

input PulseUpdateInput {
  id: String!
  timeSpent: Float!
}

input EmbedPrecacheInput {
  url: String
  attachment: String
}

type Subscription {
  onUserStatus: StatusEvent!
  onCollectionUserAdded(input: FilterCollectionInput): CollectionUser!
  onCollectionUpdated(input: FilterCollectionInput): Collection!
  onCollectionRemoved(input: FilterCollectionInput): Int!
  onCollectionCreated: Collection!
  onCollectionUserRemoved(input: FilterCollectionInput): CollectionUser!
  onCollectionUserUpdated(input: FilterCollectionInput): CollectionUser!
  onCollectionInviteCount: Int!
  onDeleteUpload: Int!
  onUpdateUploads: [Upload!]!
  onCreateUpload(input: GalleryInput): CreateUploadEvent!
  onTyping: ChatTypingEvent!
  onCancelTyping: ChatTypingEvent!
  """Returns the chat association ID"""
  onReadChat: Int!
  onMessage(input: SubscriptionMessageInput): MessageSubscription!
  onEditMessage(input: SubscriptionMessageInput): EditMessageEvent!
  onReadReceipt: ReadReceipt!
  onDeleteMessage(input: SubscriptionMessageInput): DeleteMessage!
  onAutoCollectApproval: AutoCollectApprovalEvent!
}

type StatusEvent {
  id: Int!
  status: UserStatus!
  platforms: [Platform!]
}

input FilterCollectionInput {
  collectionId: Int
}

type CreateUploadEvent {
  url: String!
  upload: Upload!
}

type ChatTypingEvent {
  chatId: Float!
  user: PartialUserFriend!
  expires: Float
}

type MessageSubscription {
  message: Message
  associationId: Int!
  mention: Boolean!
  chat: Chat!
}

input SubscriptionMessageInput {
  associationId: Int
  chatId: Int
}

type EditMessageEvent {
  associationId: Int!
  message: Message!
}

type DeleteMessage {
  id: Int!
  associationId: Int!
  chatId: Int!
}

type AutoCollectApprovalEvent {
  type: AutoCollectApprovalType!
  autoCollectApproval: AutoCollectApproval!
}

enum AutoCollectApprovalType {
  NEW
  APPROVED
  DENIED
}